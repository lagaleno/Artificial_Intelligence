# -*- coding: utf-8 -*-
"""LarissaGaleno_NRainhas.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MjkZkusmO5ufWe_ORMidBxdBDA1sg578

1. Modelagem

O tabuleiro será representado por uma lista de tamano N, logo se o tabuleiro é 4x4 a lista terá tamanho 4 ([1, 2, 3, 4]), sendo que cada posição indica em qual espaço de uma coluna a rainha está. 

2. Implementação

(a) Dado um N retorna um tabuleiro NxN com as rainhas na posição de forma aleatória
"""

from random import randint
def geraTabuleiro(N):
  tabuleiro = []
  i = 0
  while(i < N):
    tabuleiro.append(randint(0,N-1))
    i = i + 1
  
  return tabuleiro

"""(b) dado um tabuleiro retorna todos os vizinhos"""

def achaVizinhos(tabuleiro):
    N = len(tabuleiro)
    vizinhos = []  # vizinhos vai ser uma lista de listas

    for i in range(N):
        for j in range(N):
            copia_tabuleiro = tabuleiro.copy() # reseta a copia para novas comparações 
            if (j != tabuleiro[i]):  # para não considerar repetidos
                copia_tabuleiro[i] = j
                vizinhos.append(copia_tabuleiro)
            else:
                pass
            j = j + 1
        i = i + 1

    return vizinhos



def achaVizinho(tabuleiro, gerados): #retorna um possivel vizinho e vê para não retornar um que já foi gerado
  i = 0
  j = 0
  N = len(tabuleiro)
  for i in range(N):
      vizinho = tabuleiro.copy()
      for j in range(N):
          if (j != tabuleiro[i]):  # para não considerar repetidos
              vizinho[i] = j
              if vizinho not in gerados:
                  return vizinho
          j = j+1
      i = i+1

  return vizinho

#achaVizinhos([2, 1, 0, 2])
#achaVizinho([2, 1, 0, 2], [[2, 1, 0, 2]])
#achaVizinho([2, 1, 0, 2], [[0, 1, 0, 2], [1, 1, 0, 2], [3, 1, 0, 2], [2, 0, 0, 2], [2, 2, 0, 2], [2, 3, 0, 2]])

"""(c) dado um tabuleiro retorna UM dos seus vizinhos de forma aleatóroa
Essa funçaõ deve ser usada para o caso de empate
"""

def escolheVizinhoAleatorio(tabuleiro):
  vizinhos = achaVizinhos(tabuleiro)
  escolhido = randint(0, len(vizinhos)-1)
  return vizinhos[escolhido]

#escolheVizinho([2, 1, 0, 2])

"""(d) dado um tabuleiro retorna o número de ataques entre as rainhas"""

def contaAtaques(tabuleiro):
  N = len(tabuleiro)
  ataque = 0
  diagonal = 0
  lateral = 0

  #i vai de 0 até 3
  for i in range(N-1):
    #print("I = " + str(i))
    pos = tabuleiro[i]
    qtd_diagonalSup = checaDiagonalSuperior(tabuleiro, i, pos, N)
    qtd_diagonalInf = checaDiagonalInferior(tabuleiro, i, pos, N)
    diagonal = diagonal + qtd_diagonalInf + qtd_diagonalSup
    qtd_lateral = checaLateral(tabuleiro, i, pos, N)
    lateral = lateral + qtd_lateral
      
  ataque = diagonal + lateral
  return ataque

def checaLateral(tabuleiro, i, pos, N):
  #print("Estou em Lateral " + str(i))
  fixo = pos
  ataquesLateral = 0
  coluna = i + 1
  while (coluna < N):
    if tabuleiro[coluna] == pos:
      #print("Rainha da pos " + str(fixo) + " na coluna " + str(i) + " ataca rainha na coluna " + str(coluna) + " na posicao " + str(tabuleiro[coluna]))
      ataquesLateral = ataquesLateral + 1
    coluna = coluna + 1
  
  return ataquesLateral

#pos não é indice
def checaDiagonalSuperior(tabuleiro, i, pos, N):
  #print("Estou em Diagonal Superior " + str(i))
  ataquesDiagonal = 0
  coluna = i + 1
  j = 1
  while coluna < N:
    if tabuleiro[coluna] == pos-j:
      #print("Rainha da pos " + str(pos) + " na coluna " + str(i) + " ataca rainha na coluna " + str(coluna) + " na posicao " + str(tabuleiro[coluna]))
      ataquesDiagonal = ataquesDiagonal + 1
    coluna = coluna + 1
    j = j+1 
  return ataquesDiagonal

def checaDiagonalInferior(tabuleiro, i, pos, N):
  #print("Estou em Diagonal inferior " + str(i))
  ataquesDiagonal = 0
  coluna = i + 1
  j = 1
  while coluna < N:
    if tabuleiro[coluna] == pos+j:
      #print("Rainha da pos " + str(pos) + " na coluna " + str(i) + " ataca rainha na coluna " + str(coluna) + " na posicao " + str(tabuleiro[coluna]))
      ataquesDiagonal = ataquesDiagonal + 1
    coluna = coluna + 1
    
    j = j+1 
  return ataquesDiagonal

#contaAtaques([2, 1, 3, 2])

"""3. Hill Climbing

(a) Implementar o Hill climbing de forma que gera um único vizinho, ver se melhora e ai transforma em nó corrente, se não gera outro vizinho
"""

def calculaF(h):
  return -h

def hillClimbing_a(tabuleiro):
  corrente = tabuleiro
  gerados = [tabuleiro]
  h = contaAtaques(tabuleiro)
  f = calculaF(h)
  cont_corrente = 1

  #só considera o caso que encontra uma solução, se o tabuleiro não tiver solução é um problema
  while f != 0:
    vizinho = escolheVizinhoAleatorio(corrente)
    h_vizinho = contaAtaques(vizinho)
    f_vizinho = calculaF(h_vizinho)
    gerados.append(vizinho)
    if f_vizinho <= f: #código não permite andar de lado
        #print('Não chegou a uma solução, melhor f econtrado ' + str(f))
        #print('Teve ' + str(cont_corrente) + ' tabuleiros correntes ao longo da solução')
        return f, cont_corrente, corrente
    elif f_vizinho > f:
      cont_corrente = cont_corrente+1
      corrente = vizinho
      h = h_vizinho
      f = f_vizinho
  #print('Encontrou uma solução. f = ' + str(f))
  #print('Teve ' + str(cont_corrente) + ' tabuleiros correntes ao longo da solução')
  return f, cont_corrente, corrente


sucesso = 0
media_cont = 0
for i in range(100):
  tabuleiro = geraTabuleiro(32)
  f, cont, corrente = hillClimbing_a(tabuleiro)
  if f == 0:
    sucesso = sucesso + 1
  media_cont = media_cont + cont
  media = media_cont/100

print(str(sucesso) + ' sucessos em 100 execuções')
print(str(media) + ' tabuleiros correntes criados em media')

"""(b) Implementar o Hill Climbing de forma que todos os vizinhos do nó corrente são gerados, assim todos tem a função de avaliação calculada e depois é escolhido o melhor substituto para o nó corrente. Se tiver mais de um devo escolher de forma aleatória. 

"""

def escolhe(vizinhos):
  escolhido = randint(0, len(vizinhos)-1)
  return vizinhos[escolhido]

def hillClimbing_b(tabuleiro):
  corrente = tabuleiro
  h = contaAtaques(tabuleiro)
  f = calculaF(h)
  empatados = []
  cont_corrente = 1

  while f != 0:
    avaliados = []
    vizinhos = achaVizinhos(corrente)
    for i in range(len(vizinhos)): #acha todos os vizinhos, calcula a f 
      h_i = contaAtaques(vizinhos[i])
      f_i = calculaF(h_i)
      avaliados.append((f_i, vizinhos[i]))
    
    avaliados.sort() #ordenar a lista a partir do primeiro elemento da tupla
    #com o sort o tabuleiro ue quero fica no final (já que estamos lidando com negativo)
    avaliados.reverse()

    #CASO DE TER EMPATE DENTRO DE AVALIADOS
    if avaliados[0][0] == avaliados[1][0]:
      i = 1
      empatados.append(avaliados[0])
      while avaliados[0][0] == avaliados[i][0]:
        empatados.append(avaliados[i])
        i = i+1
      
      escolhido = escolhe(empatados)
      if escolhido[0] > f:
          cont_corrente = cont_corrente + 1
          corrente = escolhido[1]
          f = escolhido[0]
      else:
        #se vendo todas as configurções possiveis, não mudar nada, significa que meu nó corrente é o melhor que tenho
        #print('Não chegou a uma solução, melhor f econtrado ' + str(f))
        #print('Teve ' + str(cont_corrente) + ' tabuleiros correntes ao longo da solução')
        return f, cont_corrente, corrente

    #CASO DE NÃO TER EMPATE DENTRO DA AVALIAÇÃO DOS VIZINHOS
    else:
      if avaliados[0][0] > f:
        cont_corrente = cont_corrente + 1
        corrente = avaliados[0][1]
        f = avaliados[0][0]
      else:
        #se vendo todas as configurções possiveis, não mudar nada, significa que meu nó corrente é o melhor que tenho
        #print('Não chegou a uma solução, melhor f econtrado ' + str(f))
        #print('Teve ' + str(cont_corrente) + ' tabuleiros correntes ao longo da solução')
        return f, cont_corrente, corrente

  #print('Encontrou uma solução. f = ' + str(f))
  #print('Teve ' + str(cont_corrente) + ' tabuleiros correntes ao longo da solução')
  return f, cont_corrente, corrente

sucesso = 0
media_cont = 0
for i in range(100):
  tabuleiro = geraTabuleiro(32)
  f, cont, corrente = hillClimbing_b(tabuleiro)
  if f == 0:
    sucesso = sucesso + 1
  media_cont = media_cont + cont
  media = media_cont/100

print(str(sucesso) + ' sucessos em 100 execuções')
print(str(media) + ' tabuleiros correntes criados em media')

"""(c) 

**Número de execuções**

Letra (a)
- Quando executado com 4 casas precisei rodar o programa 7 vezes até encontrar uma solução
- Quando executado com 8 casas rodando 20 vezes não foi possível encontrar uma solução
- Quando executado com 16 casas rodando 10 vezes não foi possível encontrar uma solução
- Quando executado com 32 casas rodando 10 vezes não foi possível encontrar uma solução

Letra (b)
- Quando executado com 4 na primeira vez que rodei já encontrou solução e assim seseguiu pelas próximas 9 execuções, todas com solução
- Quando executado com 8 precisei rodar 4 vezes até encontrar a primeira solução (depois na quinta vez também encontrou, porém na sexta e sétima execuções não encontrou, na oitava voltou a encontrar e depois não encontrou mais)
- Quando executado com 16 rodando 20 vezes não foi possível encontrar uma solução
- Quando executado com 32 rodando 15 vezes não foi possível encontrar uma solução

**Compilando resultados**

<table>
  <tr>
    <th> Versão Hill Climbing </th>
    <th> Execuções </th>
    <th> N </th>
    <th> Sucessos </th>
    <th> Média de tabuleiro correntes </th>
  </tr>
  <tr>
    <td> Escolhe vizinho aleatório </td>
    <td> 100 </td>
    <td> 4 </td> 
    <td> 3 </td> 
    <td> 1.51 </td>
  </tr>
  <tr>
    <td> Escolhe vizinho aleatório </td>
    <td> 100 </td>
    <td> 8 </td>
    <td> 0 </td>
    <td> 1.61 </td>
  </tr>
  <tr>
    <td> Escolhe vizinho aleatório </td>
    <td> 100 </td>
    <td> 16 </td>
    <td> 0 </td>
    <td> 1.63 </td>
  </tr>
  <tr>
    <td> Escolhe vizinho aleatório </td>
    <td> 100 </td>
    <td> 32 </td>
    <td> 0 </td>
    <td> 1.53 </td.
  </tr>
  <tr>
    <td> Escolhe melhor vizinho </td>
    <td> 100 </td>
    <td> 4 </td>
    <td> 44 </td>
    <td> 2.52 </td>
  </tr>
  <tr>
    <td> Escolhe melhor vizinho </td>
    <td> 100 </td>
    <td> 8 </td>
    <td> 10 </td> 
    <td> 3.46 </td>
  </tr>
  <tr>
    <td> Escolhe melhor vizinho </td>
    <td> 100 </td>
    <td> 16 </td>
    <td> 0 </td>
    <td> 3.61 </td>
  </tr>
  <tr> 
    <td> Escolhe melhor vizinho </td>
    <td> 100 </td>
    <td> 32 </td>
    <td> 0 </td>
    <td> 2.97 </td>
</table>



(d)

Com os resultados apresntados acima é possível dizer que a abordagem da letra(b) tem uma maior chance de encontrar a solução, uma vez que passa por mais tabuleiros correntes que a abordagem da letra(a), uma vez que o sucesso da abordagem da letra (a) está atrelada ao aleatório (qual tabuleiro será gerado, qual será o vizinho retornado, sua função de avaliação).

4. Simulated Anneling

(a) Implementando o algoritmo
"""

import math
def simulatedAnneling(iter_max, temperatura, alfa):
  corrente = geraTabuleiro(8)
  melhor_estado = corrente
  temp_corrente = temperatura
  f = contaAtaques(corrente)

  for i in range(iter_max):
    vizinho = escolheVizinhoAleatorio(corrente)
    f_vizinho = contaAtaques(vizinho)
    delta = f_vizinho - f

    if delta <= 0:
      corrente = vizinho
      f_melhorEstado = contaAtaques(melhor_estado)
      if f_vizinho <= f_melhorEstado:
        melhor_Estado = vizinho
    
    else:
      prob = math.exp(-delta/temp_corrente)
      #print("Probailidade = " + str(prob))
      if prob > randint(0,1):
        corrente = vizinho
    
    temp_corrente = alfa*temp_corrente
  
  #print("Melhor estado encontrado com f = " + str(f_melhorEstado))
  return f, melhor_estado


sucesso = 0
for i in range(100):
  f, melhor_estado = simulatedAnneling(1000, 100, 0.5)
  if f == 0:
    sucesso = sucesso + 1

print(str(sucesso) + ' sucessos em 100 execuções')

"""<table> 
  <tr> 
    <th> Iterações </th>
    <th> Temperatura </th>
    <th> Alfa </th>
    <th> Execuções </th>
    <th> N </th> 
    <th> Sucessos </th> 
  </tr>
  <tr>
    <td> 10 </td>
    <td> 10 </td>
    <td> 0.01 </td>
    <td> 100 </td>
    <td> 4 </td>
    <td> 1 </td>
  </tr>
    <tr>
    <td> 100 </td>
    <td> 10 </td>
    <td> 0.01 </td>
    <td> 100 </td>
    <td> 4 </td>
    <td> 2 </td>
  </tr>
    <tr>
    <td> 10 </td>
    <td> 100 </td>
    <td> 0.01 </td>
    <td> 100 </td>
    <td> 4 </td>
    <td> 1 </td>
  </tr>
    <tr>
    <td> 10 </td>
    <td> 10 </td>
    <td> 0.1 </td>
    <td> 100 </td>
    <td> 4 </td>
    <td> 0 </td>
  </tr>
    <tr>
    <td> 1000 </td>
    <td> 100 </td>
    <td> 0.5 </td>
    <td> 100 </td>
    <td> 4 </td>
    <td> 1 </td>
  </tr>
</table>

Utilizando os mesmos parâmetros para N = 8 não foi possível contrar alguma solução em 100 execuções. Assim, experimentalmente, não foi possível alcançar soluções quando N = 16 ou N = 32.

Comparando o Hill Climbing e o Simulated Anneling, tendo acompanhado as discussões em sala, é possível dizer que o Simulated Anneling tem uma performance melhor para encontrar soluções, especialmente quando se aumenta o número de iterações. Entretanto, o problema está em encontrar os parâmetros ideias, que foi a minha dificuldade fazendo a tarefa.
"""